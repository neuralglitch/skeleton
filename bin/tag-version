#!/usr/bin/env php
<?php

/**
 * Version Tagging Helper Script
 * 
 * This script helps maintainers create properly formatted version tags
 * following semantic versioning conventions.
 * 
 * Usage:
 *   bin/tag-version 6.4.0
 *   bin/tag-version 6.4.1 --push
 */

// Color output helpers
function color_output(string $text, string $color): string {
    $colors = [
        'red' => "\033[31m",
        'green' => "\033[32m",
        'yellow' => "\033[33m",
        'blue' => "\033[34m",
        'cyan' => "\033[36m",
        'reset' => "\033[0m",
    ];
    
    return $colors[$color] . $text . $colors['reset'];
}

function error(string $message): void {
    echo color_output("❌ Error: ", 'red') . $message . PHP_EOL;
    exit(1);
}

function success(string $message): void {
    echo color_output("✅ ", 'green') . $message . PHP_EOL;
}

function info(string $message): void {
    echo color_output("ℹ️  ", 'blue') . $message . PHP_EOL;
}

function warning(string $message): void {
    echo color_output("⚠️  ", 'yellow') . $message . PHP_EOL;
}

// Check if running in git repository
function is_git_repo(): bool {
    exec('git rev-parse --is-inside-work-tree 2>/dev/null', $output, $returnCode);
    return $returnCode === 0;
}

// Check for uncommitted changes
function has_uncommitted_changes(): bool {
    exec('git status --porcelain', $output);
    return !empty($output);
}

// Get installed Symfony version from composer.lock
function get_installed_symfony_version(): ?string {
    $composerLockPath = __DIR__ . '/../composer.lock';
    
    if (!file_exists($composerLockPath)) {
        return null;
    }
    
    $composerLock = json_decode(file_get_contents($composerLockPath), true);
    
    if (json_last_error() !== JSON_ERROR_NONE) {
        return null;
    }
    
    // Find symfony/framework-bundle in packages
    $packages = array_merge(
        $composerLock['packages'] ?? [],
        $composerLock['packages-dev'] ?? []
    );
    
    foreach ($packages as $package) {
        if ($package['name'] === 'symfony/framework-bundle') {
            // Remove 'v' prefix if present (e.g., v6.4.15 -> 6.4.15)
            return ltrim($package['version'], 'v');
        }
    }
    
    return null;
}

// Get Symfony version (full version with patch)
function get_symfony_version(): ?array {
    // Try to get installed version first (from composer.lock)
    $installedVersion = get_installed_symfony_version();
    
    if ($installedVersion && preg_match('/^(\d+)\.(\d+)\.(\d+)/', $installedVersion, $matches)) {
        return [
            'full' => $matches[0],
            'short' => $matches[1] . '.' . $matches[2],
            'major' => (int)$matches[1],
            'minor' => (int)$matches[2],
            'patch' => (int)$matches[3],
        ];
    }
    
    // Fallback to composer.json constraint
    $composerPath = __DIR__ . '/../composer.json';
    if (!file_exists($composerPath)) {
        return null;
    }
    
    $composer = json_decode(file_get_contents($composerPath), true);
    if (json_last_error() !== JSON_ERROR_NONE) {
        return null;
    }
    
    // Check extra.symfony.require first
    if (isset($composer['extra']['symfony']['require'])) {
        $version = $composer['extra']['symfony']['require'];
    } elseif (isset($composer['require']['symfony/framework-bundle'])) {
        $version = $composer['require']['symfony/framework-bundle'];
    } else {
        return null;
    }
    
    // Extract major.minor from constraint
    if (preg_match('/(\d+)\.(\d+)/', $version, $matches)) {
        return [
            'full' => null,
            'short' => $matches[1] . '.' . $matches[2],
            'major' => (int)$matches[1],
            'minor' => (int)$matches[2],
            'patch' => null,
        ];
    }
    
    return null;
}

// Validate semantic version format
function validate_version(string $version): bool {
    // Matches: 6.4, 6.4.0, 6.4.1, etc.
    return preg_match('/^\d+\.\d+(\.\d+)?$/', $version) === 1;
}

// Validate version matches Symfony version
function validate_symfony_alignment(string $version, array $symfonyInfo): bool {
    // Tag must match either full version or start with short version
    if ($symfonyInfo['full'] !== null) {
        // If we have full version, check if tag matches short version pattern
        return str_starts_with($version, $symfonyInfo['short']);
    }
    
    // Fallback to short version matching
    return str_starts_with($version, $symfonyInfo['short']);
}

// Check if tag already exists
function tag_exists(string $tag): bool {
    exec("git tag -l '$tag'", $output);
    return !empty($output);
}

// Get current branch
function get_current_branch(): string {
    exec('git branch --show-current', $output);
    return $output[0] ?? '';
}

// Create annotated tag
function create_tag(string $version): bool {
    echo PHP_EOL;
    info("Creating annotated tag for version $version");
    echo PHP_EOL;
    
    // Prompt for release notes
    echo "Enter release notes (press Ctrl+D when done):" . PHP_EOL;
    echo color_output("Example:", 'cyan') . PHP_EOL;
    echo "  - New features added" . PHP_EOL;
    echo "  - Bug fixes" . PHP_EOL;
    echo "  - Security updates" . PHP_EOL;
    echo PHP_EOL;
    
    $releaseNotes = '';
    while ($line = fgets(STDIN)) {
        $releaseNotes .= $line;
    }
    
    $releaseNotes = trim($releaseNotes);
    
    if (empty($releaseNotes)) {
        $releaseNotes = "Release version $version";
    }
    
    $message = "Release version $version\n\n$releaseNotes";
    
    // Create the tag
    $escapedMessage = escapeshellarg($message);
    exec("git tag -a '$version' -m $escapedMessage 2>&1", $output, $returnCode);
    
    if ($returnCode !== 0) {
        error("Failed to create tag: " . implode("\n", $output));
        return false;
    }
    
    return true;
}

// Main script execution
echo PHP_EOL;
echo color_output("═══════════════════════════════════════════════════════", 'cyan') . PHP_EOL;
echo color_output("  Version Tagging Helper - Skeleton Project", 'cyan') . PHP_EOL;
echo color_output("═══════════════════════════════════════════════════════", 'cyan') . PHP_EOL;
echo PHP_EOL;

// Parse arguments
$version = $argv[1] ?? null;
$shouldPush = in_array('--push', $argv) || in_array('-p', $argv);

// Validate arguments
if ($version === null) {
    error("Version number is required\n\nUsage: bin/tag-version <version> [--push]\nExample: bin/tag-version 6.4.0");
}

if (!validate_version($version)) {
    error("Invalid version format: $version\n\nExpected format: MAJOR.MINOR[.PATCH]\nExamples: 6.4, 6.4.0, 6.4.1");
}

// Validate against Symfony version
$symfonyInfo = get_symfony_version();
if ($symfonyInfo !== null) {
    if (!validate_symfony_alignment($version, $symfonyInfo)) {
        $displayVersion = $symfonyInfo['full'] ?? $symfonyInfo['short'];
        error("Version mismatch!\n\nTag version: $version\nSymfony version: $displayVersion\n\nTags must match the Symfony version.\nExpected: $displayVersion or {$symfonyInfo['short']}.x\n\nRun 'bin/detect-symfony-version' to see suggested versions.");
    }
    
    $displayVersion = $symfonyInfo['full'] ?? $symfonyInfo['short'];
    
    success("Version aligns with Symfony {$symfonyInfo['short']}");
} else {
    warning("Could not detect Symfony version from composer.json or composer.lock");
}

// Show Symfony version info
if ($symfonyInfo !== null) {
    $displayVersion = $symfonyInfo['full'] ?? $symfonyInfo['short'];
    info("Detected Symfony version: " . color_output($displayVersion, 'cyan'));
    echo PHP_EOL;
}

// Pre-flight checks
info("Running pre-flight checks...");
echo PHP_EOL;

if (!is_git_repo()) {
    error("Not a git repository");
}
success("Git repository detected");

$currentBranch = get_current_branch();
if ($currentBranch !== 'main' && $currentBranch !== 'master') {
    warning("You are not on the main/master branch (current: $currentBranch)");
    echo "Continue anyway? [y/N]: ";
    $response = trim(fgets(STDIN));
    if (strtolower($response) !== 'y') {
        echo "Aborted." . PHP_EOL;
        exit(0);
    }
}

if (has_uncommitted_changes()) {
    warning("You have uncommitted changes");
    echo "Continue anyway? [y/N]: ";
    $response = trim(fgets(STDIN));
    if (strtolower($response) !== 'y') {
        echo "Aborted." . PHP_EOL;
        exit(0);
    }
}
success("No uncommitted changes");

if (tag_exists($version)) {
    error("Tag '$version' already exists\n\nUse 'git tag -d $version' to delete it first");
}
success("Tag name is available");

echo PHP_EOL;

// Create tag
if (!create_tag($version)) {
    exit(1);
}

success("Tag '$version' created successfully");

// Show tag info
echo PHP_EOL;
info("Tag information:");
echo PHP_EOL;
exec("git show $version --no-patch", $output);
echo implode("\n", $output) . PHP_EOL;

// Push tag
echo PHP_EOL;
if ($shouldPush) {
    info("Pushing tag to remote...");
    exec("git push origin $version 2>&1", $output, $returnCode);
    
    if ($returnCode !== 0) {
        error("Failed to push tag: " . implode("\n", $output));
    }
    
    success("Tag pushed to remote");
} else {
    info("To push this tag to remote, run:");
    echo color_output("  git push origin $version", 'cyan') . PHP_EOL;
    echo PHP_EOL;
    info("Or push all tags:");
    echo color_output("  git push origin --tags", 'cyan') . PHP_EOL;
}

echo PHP_EOL;
info("Next steps:");
echo "  1. Create a GitHub release: " . color_output("https://github.com/neuralglitch/skeleton/releases/new", 'cyan') . PHP_EOL;
echo "  2. Select tag: " . color_output($version, 'green') . PHP_EOL;
echo "  3. Add release notes and publish" . PHP_EOL;
echo PHP_EOL;

success("Done! Version $version is ready.");
echo PHP_EOL;

